# 1.1.1 싱글톤 패턴 -> 1클래스 1인스턴스
-데이터 베이스 연결 모듈에 많이 쓰임

-미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴

  -> '독립적인' 인스턴스 만들기어렵
  
  -> 모듈간 결합이 강해 의존성 주입(직접x, 의존성 주입자를 만들어 얘를 시킴) 필요
      -->의존성 감소= 디커플링 된다. But 단점) 모듈들이 더욱 분리되므로 클래스 수 증가 -> 복잡성 증가

---
# 1.1.2 팩토리 패턴
: 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴 ( 상위 클래스 = 뼈대 , 하위 클래스 = 구체적인 )
 ex) 상위 : 커피,  하위 : 라떼, 아메리카노, 카푸치노

- 상위 클래스와 하위 클래스의 분리로 느슨한 결합, 유지보수성 증가

---
# 1.1.3 전략 패턴 = 정책 패턴
: 객체의 행위를 바꾸고 싶은 경우, '직접' 수정 x, '캡슐화한 알고리즘'을 컨텍스트(상황, 맥락, 문맥) 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴
ex) 결제할 때, naver pay, kakao pay 등을 선택하는 것처럼

---
# 1.1.4 옵저버 패턴
:주체가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 패턴
- 주체 : 객체의 상태 변화를 보고 있는 관찰자
- 옵저버 : 객체의 상태 변화에 따라 '추가 변화 사항'이 생기는 객체들

 ex) 트위터- 어떤 사람인 주체를 팔로우 했다면 주체가 포스팅 할때마다 팔로워에게 알림

 - 주로 이벤트 기반 시스템, MVC(Model - View - Controller) 패턴에 사용
     -> 주체인 모델에 변경 사항이 생겨 update() 메서드로 옵저번인 뷰에게 알려주고 이를 기반으로 컨트롤러 등이 작동하는 것


++++뽀나스++++자바 : 상속과 구현
- 상속 : 자식이 부모의 특징을 상속받아 사용, 자식이 원하는 특징을 추가 및 확장 가능
        ->일 반 클래스, abstract 클래스를 기반으로 구현
  
- 구현 : 특정 인터페이스를 클래스에서 구현, 해당 인터페이스에를 구현한 클래스에서는 인터페이스의 메소드를 재정의 함으로써 구현
        -> 인터페이스를 기반으로 구현

---
# 1.1.5 프록시 패턴과 프록시 서버
:대상 객체(subject)에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을하는 패턴

- 프록시 객체(프록시 패턴이 녹아있음)
  : 어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체

-프록시 서버(nginx) 
  :서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템/응용 프로그램

  -> 프록시 서버로 쓰는 CloudFlare (CDN 서비스 : 지리적으로 분산된 서버들을 연결한 네트워크)
      --> CloudFlare는 웹 서버 앞단에 프록시 서버로 두어 DDOS 공격 방어나 HTTPS 구축에 쓰임

      * DDOS 공격 방어
      :DDOS는 짧은 기간 동안 네트원크에 많은 요청을 보내 네트워크를 마비시켜 웹 사이트의 가용성을 방해하는 사이버 공격 유형
      ->의심스러운 트래픽,사용자가 접속하는 것이 아닌 시스템을 통해 오는 트래픽을 자동으로 차단하여 보호

      *HTTPS 구축
      :CloudFlare를 사용하면 별도의 인증서 설치없이 손쉽게 HTTPS 구축

  -> 
