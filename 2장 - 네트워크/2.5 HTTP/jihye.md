# 2.5 HTTP

# 5.1 HTTP/1.0
- 한 연결당 하나의 요청을 처리
    - 이는 RTT 증가를 불러옴(-)
    - RTT: 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간 = 패킷 왕복 시간
    - ![image](https://github.com/codesooo/cs-study-jj/assets/129932517/87a33bf0-d6ce-420b-83ae-b4267e689ff5)

- RTT 증가 해결법
  |이미지 스플리팅|코드 압축|이미지 Base64인코딩|
  -----
  |이미지가 합쳐 있는 하나의 이미지를 다운받고 이를 기반으로 background-image의 position을 이용하여 이미지 표기|코드를 압축해서 개행 문자, 빈칸을 없애서 코드의 크기를 최소화|이미지 파일을 64진법으로 이루어진 문자열로 인코딩|

  - 인코딩: 정보의 형태나 형식을 표준화,보안,처리 속도 향상, 저장 공간 절약 등을 위해 다른 형태나 형식으로 변환하는 처리방식


# 5.2 HTTP/1.1
- 매번 TCP 연결을 하는 것이 아니라 한 번 TCP 초기화를 한 이후에 keep-alive라는 옵션을 여러 개으 ㅣ파일을 송수신
- ![image](https://github.com/codesooo/cs-study-jj/assets/129932517/7a8b3dcf-4603-4dce-80c3-c7666a09be89)
- 다음 그림은 한 번 tcp-3웨이 핸드셰이크가 발생하면 그 다음부터 발생하지 않는 것을 볼 수 있다.
- (-) 문서안에 포함된 다수의 리소스를 처리하려면 요청할 리소스 개수에 비례해서 대기 시간이 길어짐

- 단점
  - HOL Blocking
    - 네트워크에서 같은 큐에 있는 패킷이 그 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상
    - ![image](https://github.com/codesooo/cs-study-jj/assets/129932517/4420e26f-76d3-4a06-af28-44797abd9255)
    - 무거운 헤더 구조 : 많은 메타데이터가 들어가 잇고 압축이 되지 않아 무거움
   
# 5.3 HTTP/2
- HTTP/2는 SPDY 프로토콜에서 파생된 HTTP/1.x보다 지연 시간을 줄이고 응답 시간을 더 빠르게 할 수 있으며 멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리를 지원하는 프로토콜
  ## 멀티 플렉싱
  :여러개의 스트림을 사용하여 송수신

  - 이를 통해 특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림은 멀쩡하게 동작
  - 스트림 : 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 데이터 흐름

   -> HOL Blocking 해결


  ## 헤더 압축
  : 허프만 코딩 압축 알고리즘을 사용하는 HPACK 압축 형식을 가짐
  - 허프만 코딩 : 문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트 수를 사용하여 표현하고, 빈도가 낮은 정보는 비트 수를 많이 사용하여 표현해서 전체 데이터의 표현에 필요한 비트양을 줄이는 원리

  ## 서버 푸시
  : 클라이언트 요청 없이 서버가 바로 리소스를 푸시
  ![image](https://github.com/codesooo/cs-study-jj/assets/129932517/f2e4210c-9267-45fb-aad0-869670fa8a3f)

  # 5.4 HTTPS
  :HTTP/2는 HTTPS 위에서 동작

  애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP 요청

  -> 통신 암호화


  ## SSL/TLS
  :전송 계층에서 보안을 제공하는 프로토콜

  클라이언트와 서버가 통신 할 때 SSL/TLS 를 통해 제3자가 메시지를 도청하거나 변조하지 못하도록 함


  ![image](https://github.com/codesooo/cs-study-jj/assets/129932517/846c0f91-218c-4a35-89e0-4947666b45b5)

  그림처럼 SSL/TLS를 통해 공격자가 서버인 척하며 사용자 정보를 가로채는 네트워크 상의 '인터셉터'를 방지할 수 있다.

  SSL/TLS는 보안 세션을 기반으로 데이터를 암호화하며 보안 세션이 만들어질 때 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘이 사용됨

  - 보안 세션
    :보안이 시작되고 끝나는 동안 유지되는 세션

    SSL/TLS는 핸드셰이크를 통해 보안 세션을 생성하고 이를 기반으로 상태 정보 등을 공유

    - 세션 : 운영체제가 어떠한 사용자로부터 자신의 자산 이용을 허락하는 일정한 기간, 즉 사용자는 일정 시간 동안 응용 ㅍ흐로그램, 자원 등을 사용 가능
    - TLS의 핸드셰이크
    - ![image](https://github.com/codesooo/cs-study-jj/assets/129932517/05f69ddf-6153-428d-a71d-e2ea1379fb8b)
    - 
    #### 사이퍼슈트
    : 프로토콜, AEAD 사이퍼모드, 해싱 알고리즘이 나열된 규약
- TLS_AES_128_GCM_SHA256
- TLS_AES_256_GCM_SHA384
- TLS_CHACHA20_POLY1305_GCM_SHA256
- TLS_AES_128_CCM_SHA256
- TLS_AES_128_GCM_8_SHA256

  - EX. TLS_AES_128_GCM_SHA256에는 세가지 규약
    - TLS : 프로토콜
    - AES_128_GCM : AEAD 사이퍼 모드
    - SHA256 : 해싱 알고리즘

    #### AEAD 사이퍼모드
    : 데이터 암호화 알고리즘이며 AES_128_GCM 등이 있다.
    - 예를 들어, AES_128_GCM,이라는 것은 128 비트의 키를 사용하는 표준 블록 암호화 기술과 병렬 계산에 용이한 암호화 알고리즘 GCM이 결합된 알고리즘을 뜻함
   
      
## 인증 메커니즘
#### CA 발급 과정
자신의 서비스가 CA 인증서를 발급받으려면 자신의 사이트 정보와 공개키를 CA에 제출해야 한다. 이후 CA는 공개키를 해시한 값인 지문을 사용하는 CA의 비밀 키 등을 기반으로 CA인증서를 발
    - 개인키 : 비밀키, 개인이 소유하고 있는 키, 반드시 자신만이 소유해야하는 키
    - 공개키
   
## 암호화 알고리즘
키 교환 암호화 알고리즘으로는 대수곡선 기반의 ECDHE(Elliptic Curve Diffie-Hellman Ephermeral) 또는 모듈기반의 DHE(Diffie-Hellman Ephermeral)를 사용

둘 다 디피-헬만 방식을 근간으로 만들어짐

#### 디피-헬만 키 교환 암호화 알고리즘
- 암호키를 교환하는 하나의 방법
- ![image](https://github.com/codesooo/cs-study-jj/assets/129932517/c8f09888-079a-47a1-9d73-c5a96cf66ba9)
- 그림처럼 처음에 공개 값을 공유하고 각자의 비밀 값과 혼합한 후 혼합 값을 공유
- 그 다음 각자의 비밀 값과 또 혼합
- 그 이후에 암호키인 PSK(Pre-Shared Key)가 생성됨

- > 이렇게 클라이언트와 서버 모두 개인키와 공개키를 생성하고, 서로에게 공개키를 보내고 공개키와 개인키를 결합하여 PSK가 생성된다면, 악의적인 공격자가 개인키 또는 공개키를 가지고도 PSK가 없기 때문에 아무것도 할 수 없져?
  > 이를  통해 키를 암호화할 수 있음


## 해싱 알고리즘
#### SHA-256 알고리즘
    - 해시
    - 해싱
    - 해시 함수

## SEO에도 도움이 되는 HTTPS


## HTTPS 구축 방법

# 5.5 HTTP/3

## 초기 연결 설정 시 지연 시간 감
    
    ![image](https://github.com/codesooo/cs-study-jj/assets/129932517/a4237b3d-b67f-45a7-9379-3174022b7bf3)





